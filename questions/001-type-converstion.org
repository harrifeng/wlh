* 类型转换
  + 题目
    #+begin_example
      有两个变量a和b，在执行了如下代码后：

      a = 32768;
      b = a;
      printf("%d %d\n", a, b);
      输出两个数：32768 -32768

      请问a和b分别是以下哪种类型？

      A. bool   B. char   C. short   D. int   E. float   F. double
    #+end_example
  + 理解这个题目需要一些计算机的基础知识:
    - c++这个语言的诞生是在c的基础之上,增加了模板编程(stl都是使用模板编程),面向对
      象编程,并且提供了标准库(standard library)
    - c++之所以流行,是因为它和纯c百分之百兼容
    - 在c++之前,几乎所有的代码都是c写的
    - c之所以能够发展起来,是因为c是用来替代汇编语言的.
    - 最早所有的代码都是汇编语言写的,可以说汇编语言是最底层的了,因为汇编的语句都
      是cpu开发商(比如英特尔)设计的
    - c为了能够和汇编配合的比较好(同时为了节省资源),所以很多概念都非常的底层,就是
      为了能够把"老的用汇编写的代码"改编成"用c写的代码"
  + 好,下面来看看c是如何和底层设计联系起来的:
  + 首先看看x-bit的概念.一个bit就是0或者1, 计算机是二进制的,所以只有0和1
    - 计算机分成'x-bit机',意思是cpu一次处理的二进制数据长度是多少(这句比较难以理
      解,可以回来再看)
    - 最早的计算机是8bit的(注意是bit,不是byte,一个byte等于8个bit,所以电信公司很鸡
      贼,它给你家的宽带标注的是10Mb,是小b,所以你下载最多只能下载到1.25MB,因为计算
      机上面都是用大B). 比如早期的游戏机红白机,我们小时候就叫"8位机"
    - 后来短暂的出现了16bit机.世嘉土星游戏机就是16位机
    - 流行时间最长的就是32bit机,从80386开始,一直到几年前,都是32bit机
    - 现在是64bit机时代
  + c语言为了能够兼容,设计出完整的匹配上面x-bit的类型:
    - bool: 1bit
    - char: 8bit
    - short: 16bit
    - int: 32bit(在32位机器上面), 64bit(在64位机器上面)
    - long: 64bit
  + 但是,我们的时间是有正数和负数的,所以这个时候就需要拿出一个bit来用来做符号,所
    以真正能用的位置是(bool不需要符号)
    - char: 7bit
    - short: 15bit
    - int: 31bit(在32位机器上面), 63bit(在64位机器上面)
    - long: 63bit
  + 说到符号,另外一个令人头大的概念又出来了,那就是补码!
  + 先说结论,如果你记不住使用补码的原因,就记住这个结论
    #+begin_example
      补码的诞生是为了让"减法"计算和"加法"的计算方法一样,计算更容易,为
      了方便计算机,所以人看起来肯定费劲
    #+end_example
  + 我们先来看看,没有补码的情况下是怎么处理的(你只需要理解没有补码是怎么处理的就
    可以了,补码你学有余力再看,因为你不理解补码会发现调试的时候打印的值难以理解)
  + 前面说了我们为了让数值能够处理正数和负数,所以留了一个bit来存储符号,很容易理解
    的办法就是让0代表正数,1代表负数,所以以char类型为例,易于人类理解的设计是这样
    的,比如正3和负3:
    - 正三用二进制来表示: 00000011
    - 负三用二进制来表示: 10000011
  + 上面这种易于人类理解的负数表达方式叫做"反码"
  + 好,那我们来计算一下char类型(1个bit符号,7个bit的数值,其数据范围是多少):
    - 正数范围:00000000[十进制是0]到01111111[十进制是127]
    - 负数范围:11111111[十进制-127]到1000000[十进制-0,也就是0]
    - 整体的范围是-127到127
  + 好了,看结论
    #+begin_example
      在没有使用补码的情况下,最朴素的设计方法,会把X-bit设计成一个范围是
      从"-2的X-1次方减去1"到"+2的X-1次方减去1"
    #+end_example
  + 计算机没那么简单,为了让cpu计算起来方便,引入了补码.补码的特点:
    - 正数的补码和原码相同
    - 负数的补码是其反码加1
    - 补码为了节省空间,把正0保留,把负数0(就是前面的1000000)表示成了最小值-128
      所以补码的范围是
      #+begin_example
        从"-2的X-1次方"到"+2的X-1次方减去1"
      #+end_example
  + 好了,如果你不明白上面的论述,你只需要记住,由于计算机的设计都是补码,所以(即便
    这篇文章你都不懂的话,也要背下来下面的结论):
    - char取值范围是-128到127
    - short的取值范围是-32768到32767
    - int 32位的取值范围是-2147483648到
* 题目分析
  + 好了,我们回到题目,先看看a. a被"赋予了32768,并且成功打印了32768",所以a的取值
    范围肯定大于32768.
  + 注意这个论断包含两个方面:
    - 第一可以被赋予32768(即便你的范围不在这个区间,也可以被赋予这个区间的值,这是c
      语言特别难的地方,它会各种的切割,转换,让赋值完成,但是并不合理)
      #+begin_src c++
        #include <iostream>

        using namespace std;

        int main(int argc, char *argv[])
        {
            char a = 129;
            printf("%d\n", a);
            return 0;
        }


        // <===================OUTPUT===================>
        // /Users/hfeng/github/wlh/questions/test1.cc:7:14: warning: implicit conversion from 'int' to 'char' changes value from 129 to -127 [-Wconstant-conversion]
        //     char a = 129;
        //          ~   ^~~
        // 1 warning generated.
        // -127
      #+end_src
    - 第二能成功打印出来,上面的例子,赋值成功了,但是打出来不对
  + 所以综合评判a的范围肯定大于short,所以是int(float和double是浮点数问题又不一样,
    你不用考虑他们了)
  + 而b能够被赋予32768,但是打印出来却不对,说明它肯定比int小(否则就和a的行为一致了)
    比int小的类型有:
    - short
    - char
    - bool
  + 但是它只可能是short,因为如果是char的话,会打印-127, 是bool的话,只能打印出0或者1
  + 综上输出结果应该是
    #+begin_example
      D C
    #+end_example
